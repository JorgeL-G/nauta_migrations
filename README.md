# Nauta Migrations

Sistema de gestión de migraciones para MongoDB usando Python y pymongo.

## Características

- ✅ Crear nuevas migraciones con plantilla
- ✅ Ejecutar migraciones pendientes
- ✅ Revertir migraciones (rollback)
- ✅ Consultar estado de migraciones
- ✅ Listar todas las migraciones
- ✅ Seguimiento de versiones en la base de datos
- ✅ Validación de esquema con $jsonSchema
- ✅ Soporte para campos datetime
- ✅ Creación y gestión de índices (B-tree y sparse)

## Instalación

### Requisitos

- Python 3.8 o superior (recomendado 3.10)
- MongoDB
- Anaconda o Miniconda (opcional, pero recomendado)

### Instalación con Anaconda (Recomendado)

1. Clonar o descargar el proyecto:
```bash
cd nauta_migrations
```

2. Crear y activar el entorno virtual con conda:
```bash
# Crear el entorno desde el archivo environment.yml
conda env create -f environment.yml

# Activar el entorno
conda activate nauta_migrations
```

3. Instalar el paquete en modo desarrollo:
```bash
pip install -e .
```

4. Configurar variables de entorno:
```bash
cp .env.example .env
```

### Instalación sin Anaconda

1. Clonar o descargar el proyecto:
```bash
cd nauta_migrations
```

2. Instalar dependencias:
```bash
pip install -r requirements.txt
```

3. Instalar el paquete en modo desarrollo:
```bash
pip install -e .
```

4. Configurar variables de entorno:
```bash
cp .env.example .env
```

Editar el archivo `.env` con tus configuraciones:
```env
MONGODB_URL=mongodb://localhost:27017/nauta_db
MONGODB_DATABASE=nauta_db
MIGRATIONS_DIR=migrations
```

## Uso

### Comandos Disponibles

#### Crear una nueva migración

```bash
nauta-migrate create "descripción de la migración"
```

Esto creará un archivo en el directorio `migrations/` con el formato `YYYYMMDDHHMMSS_descripcion.py`.

#### Ejecutar migraciones pendientes

```bash
nauta-migrate migrate
```

Aplica todas las migraciones pendientes en orden cronológico.

#### Revertir una migración

```bash
# Revertir la última migración
nauta-migrate rollback

# Revertir una migración específica
nauta-migrate rollback --migration 20231104120000_agregar_campo.py
```

#### Consultar estado

```bash
nauta-migrate status
```

Muestra el estado de todas las migraciones: totales, aplicadas y pendientes.

#### Listar migraciones

```bash
nauta-migrate list
```

Lista todas las migraciones disponibles y su estado.

## Formato de Migraciones

Las migraciones son archivos Python que contienen una clase `Migration` que hereda de `BaseMigration`. Cada migración debe implementar:

- `upgrade()`: Método para aplicar los cambios
- `downgrade()`: Método para revertir los cambios

### Ejemplo de Migración

#### Ejemplo básico: Agregar campo

```python
"""
Migration: Add email field to users
Created: 2023-11-04 12:00:00
"""

from nauta_migrations.migrate import BaseMigration


class Migration(BaseMigration):
    """Add email field to users"""
    
    def upgrade(self):
        """
        Apply changes to the database.
        Access the database using self.db
        """
        # Add email field with default value
        self.db.usuarios.update_many(
            {},
            {"$set": {"email": ""}}
        )
    
    def downgrade(self):
        """
        Revert changes applied in upgrade().
        """
        # Remove email field
        self.db.usuarios.update_many(
            {},
            {"$unset": {"email": ""}}
        )
```

#### Ejemplo avanzado: Crear colección con validación de esquema

```python
"""
Migration: create_collection_transactions
Created: 2025-11-04 15:56:56

Creates the 'transactions' collection with schema validations:
- ID: automatically generated by MongoDB (_id)
- Amount: Double, required, greater than 0
- Currency: Enum (USD, EUR, MXN, etc.), required
- Transaction date: required, cannot be in the future
- Category: String, optional (ALIMENTOS, ENTRETENIMIENTO, SALUD, etc.)
- created_at: automatic timestamp
"""

from nauta_migrations.migrate import BaseMigration


class Migration(BaseMigration):
    """Create transactions collection with validations"""
    
    def upgrade(self):
        """
        Create the 'transactions' collection with schema validation.
        """
        collection_name = "transactions"
        
        # Schema validation using $jsonSchema combined with $expr for dynamic date validation
        validator = {
            "$and": [
                {
                    "$jsonSchema": {
                        "bsonType": "object",
                        "required": ["amount", "currency", "transaction_date", "created_at"],
                        "properties": {
                            "_id": {
                                "bsonType": "objectId",
                                "description": "ID automatically generated by MongoDB"
                            },
                            "amount": {
                                "bsonType": "double",
                                "description": "Transaction amount (required, must be greater than 0)",
                                "minimum": 0
                            },
                            "currency": {
                                "enum": ["USD", "EUR", "MXN", "GBP", "JPY", "CAD", "AUD", "CHF", "CNY", "BRL"],
                                "description": "Transaction currency (required)",
                            },
                            "transaction_date": {
                                "bsonType": "date",
                                "description": "Transaction date (required, cannot be in the future)"
                            },
                            "category": {
                                "bsonType": "string",
                                "description": "Transaction category (optional)"
                            },
                            "created_at": {
                                "bsonType": "date",
                                "description": "Document creation date and time - datetime (required)"
                            }
                        }
                    }
                },
                {
                    "$expr": {
                        "$lte": ["$transaction_date", "$$NOW"]
                    }
                }
            ]
        }
        
        # Create collection with validation
        try:
            if collection_name in self.db.list_collection_names():
                print(f"Collection '{collection_name}' already exists. Skipping creation.")
                return
            
            self.db.create_collection(
                collection_name,
                validator=validator,
                validationLevel="strict",
                validationAction="error"
            )
            
            print(f"✓ Collection '{collection_name}' created successfully with validations")
            
        except Exception as e:
            print(f"✗ Error creating collection '{collection_name}': {e}")
            raise
    
    def downgrade(self):
        """
        Drop the 'transactions' collection.
        """
        collection_name = "transactions"
        
        try:
            if collection_name in self.db.list_collection_names():
                self.db.drop_collection(collection_name)
                print(f"✓ Collection '{collection_name}' dropped successfully")
            else:
                print(f"Collection '{collection_name}' does not exist. Nothing to drop.")
        except Exception as e:
            print(f"✗ Error dropping collection '{collection_name}': {e}")
            raise
```

#### Ejemplo: Agregar índices a una colección

```python
"""
Migration: add_indexes_currency_category_transactions
Created: 2025-11-05 15:15:29

Adds indexes to the 'transactions' collection:
- Index on 'currency' field (standard B-tree index) - for required enum field with limited values
- Index on 'category' field (sparse index) - for optional field that may be absent in some documents
"""

from nauta_migrations.migrate import BaseMigration


class Migration(BaseMigration):
    """Add indexes to currency and category fields in transactions collection"""
    
    def upgrade(self):
        """
        Create indexes on currency and category fields in the transactions collection.
        """
        collection_name = "transactions"
        
        try:
            # Verify collection exists
            if collection_name not in self.db.list_collection_names():
                print(f"Collection '{collection_name}' does not exist. Cannot create indexes.")
                return
            
            collection = self.db[collection_name]
            
            # Get existing indexes to avoid duplicates
            existing_indexes = [idx["name"] for idx in collection.list_indexes()]
            
            # Create index on currency field (standard B-tree index)
            if "currency_1" not in existing_indexes:
                collection.create_index("currency")
                print(f"Index created on 'currency' field in '{collection_name}' collection")
            else:
                print(f"Index on 'currency' field already exists. Skipping.")
            
            # Create sparse index on category field
            if "category_1" not in existing_indexes:
                collection.create_index("category", sparse=True)
                print(f"Sparse index created on 'category' field in '{collection_name}' collection")
            else:
                print(f"Index on 'category' field already exists. Skipping.")
            
        except Exception as e:
            print(f"Error creating indexes in '{collection_name}' collection: {e}")
            raise
    
    def downgrade(self):
        """
        Remove indexes from currency and category fields in the transactions collection.
        """
        collection_name = "transactions"
        
        try:
            if collection_name not in self.db.list_collection_names():
                print(f"Collection '{collection_name}' does not exist. Nothing to do.")
                return
            
            collection = self.db[collection_name]
            existing_indexes = {idx["name"]: idx for idx in collection.list_indexes()}
            
            # Drop index on currency field
            if "currency_1" in existing_indexes:
                collection.drop_index("currency_1")
                print(f"Index dropped on 'currency' field in '{collection_name}' collection")
            
            # Drop sparse index on category field
            if "category_1" in existing_indexes:
                collection.drop_index("category_1")
                print(f"Sparse index dropped on 'category' field in '{collection_name}' collection")
            
        except Exception as e:
            print(f"Error dropping indexes in '{collection_name}' collection: {e}")
            raise
```

## Estructura del Proyecto

```
nauta_migrations/
├── migrations/              # Directorio de migraciones
│   └── YYYYMMDDHHMMSS_*.py
├── nauta_migrations/        # Módulo principal
│   ├── __init__.py
│   ├── cli.py              # Interfaz de línea de comandos
│   ├── config.py           # Configuración
│   └── migrate.py          # Lógica de migraciones
├── .env                    # Variables de entorno (no versionar)
├── .env.example            # Plantilla de variables de entorno
├── requirements.txt        # Dependencias
├── setup.py               # Configuración del paquete
└── README.md              # Este archivo
```

## Seguimiento de Versiones

El sistema registra las migraciones aplicadas en una colección `_migrations` en la base de datos MongoDB. Cada registro contiene:

- `version`: Identificador de la migración
- `name`: Nombre del archivo
- `description`: Descripción de la migración
- `applied_at`: Fecha y hora de aplicación

## Opciones de Línea de Comandos

Todos los comandos aceptan opciones para sobrescribir la configuración:

- `--mongodb-url`: URL de conexión a MongoDB
- `--database`: Nombre de la base de datos
- `--migrations-dir`: Directorio de migraciones

Ejemplo:
```bash
nauta-migrate migrate --mongodb-url mongodb://localhost:27017/otra_db --database otra_db
```

## Notas Técnicas

### Validación de Esquema

El sistema soporta validación de esquema usando `$jsonSchema` de MongoDB. Esto permite definir reglas de validación estrictas para las colecciones.

### Tipos de Datos

- **decimal**: Para valores monetarios (precisión exacta)
- **date**: Para campos de fecha y hora (datetime)
- **string**: Para texto
- **enum**: Para valores predefinidos

### Verificación de Objetos Database

Los objetos `Database` de PyMongo no pueden ser evaluados directamente en condiciones booleanas. Use `if self.db is None:` en lugar de `if not self.db:`.

## Desarrollo

### Ejecutar comandos sin instalar

```bash
python -m nauta_migrations.cli create "descripción"
```

## Licencia

Este proyecto es de uso interno.

## Soporte

Para problemas o preguntas, contactar al equipo de desarrollo.

